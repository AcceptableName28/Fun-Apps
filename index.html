<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vespa Jump</title>
  <style>
    :root { --sky:#cfe9ff; --road:#2a2a2a; }
    html,body{height:100%;margin:0;background:var(--sky);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #wrap{display:grid;place-items:center;height:100%}
    canvas{background:linear-gradient(#cfe9ff, #a6d4ff 60%);box-shadow:0 10px 40px rgba(0,0,0,.25);border-radius:14px}

    .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.85);text-align:center}
    .card{background:#fff;border-radius:14px;box-shadow:0 12px 36px rgba(0,0,0,.2);padding:20px 28px}
    .btn{display:inline-block;background:#111;color:#fff;padding:10px 16px;border-radius:10px;font-weight:800;margin-top:10px}
    kbd{background:#111;color:#fff;border-radius:6px;padding:3px 6px;font-weight:700}
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="540" aria-label="Vespa Jump game"></canvas>
  </div>

  <!-- Start -->
  <div id="startScreen" class="overlay">
    <div class="card">
      <h1 style="margin:0 0 8px">üõµ Vespa Jump</h1>
      <div>Press <kbd>Space</kbd> or <kbd>‚Üë</kbd> to jump. Press again mid-air for a double jump.<br/>After a crash, press <kbd>R</kbd> or click Restart.</div>
      <a href="#" id="startBtn" class="btn">Start</a>
    </div>
  </div>

  <!-- Game Over -->
  <div id="gameOver" class="overlay" style="display:none">
    <div class="card">
      <h2 style="margin:0 0 8px">Game Over</h2>
      <div>Score: <span id="finalScore">0</span> ¬∑ Best: <span id="finalBest">0</span></div>
      <a href="#" id="restartBtn" class="btn">Restart (R)</a>
    </div>
  </div>

  <script>
    // ===== Canvas =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // ===== UI =====
    const startScreen = document.getElementById('startScreen');
    const gameOverEl  = document.getElementById('gameOver');
    const startBtn    = document.getElementById('startBtn');
    const restartBtn  = document.getElementById('restartBtn');
    const finalScore  = document.getElementById('finalScore');
    const finalBest   = document.getElementById('finalBest');

    // ===== Sprite (your PNG) =====
    const vespaImg = new Image();
    vespaImg.src = 'Blue Vespa Right.png'; // keep next to this HTML
    let vespaReady = false;
    vespaImg.onload = () => vespaReady = true;

    // ===== Physics / Tuning =====
    const floorY = H * 0.78;
    const gravity       = 0.9;     // snappy fall
    const JUMP_VEL_1    = -14.5;   // first jump
    const JUMP_VEL_2    = -12.2;   // double jump
    const COYOTE_FRAMES = 8;       // grace frames after leaving ground
    const BUFFER_FRAMES = 10;      // queue jump presses

    // ===== World =====
    const world = {
      t: 0,
      speed: 8,            // base road & obstacle scroll speed
      baseSpeed: 8,
      maxSpeed: 17,        // slightly lowered top speed for usability
      score: 0,
      best: Number(localStorage.getItem('vespa_best') || 0),
      alive: false,
      // spawn control using cooldown frames (wider gaps to start)
      spawnCooldown: 0,
      nextSpawnMin: 110,   // min frames between spawns (user friendly)
      nextSpawnMax: 170,   // max frames between spawns
      difficultyTimer: 0
    };

    // ===== Input =====
    const keys = { up:false, space:false };
    const KEY  = { UP:38, SPACE:32, R:82 };

    // ===== Player =====
    const PLAYER_W = 120;  // sized like your previous scooter
    const PLAYER_H = 80;
    const player = {
      x: W*0.18, y: floorY, vy: 0,
      w: PLAYER_W, h: PLAYER_H,
      onGround: true, jumps: 0,
      coyote: 0, jumpBuffer: 0, usedDouble: false
    };

    // ===== Obstacles (triangles) =====
    const TRI_COLORS = ['#ff6b6b','#ffd166','#06d6a0','#118ab2','#8338ec','#ef476f','#f9c74f','#90be6d'];
    const obstacles = [];
    function spawnTriangle(){
      // random triangle sizes, but reasonable for jumping
      const base  = 36 + Math.random()*42;   // width at base
      const high  = 40 + Math.random()*80;   // height
      const color = TRI_COLORS[(Math.random()*TRI_COLORS.length)|0];
      // triangles sit on the floor
      obstacles.push({
        kind:'tri',
        x: W + 40,
        y: floorY,      // base line y
        base, height: high,
        color
      });
      // set next spawn cooldown to a safe, user-friendly range
      world.spawnCooldown = randInt(world.nextSpawnMin, world.nextSpawnMax);
    }

    // ===== Helpers =====
    function randInt(a,b){ return (a + Math.random()*(b-a))|0; }
    function hardResetInput(){ keys.up=false; keys.space=false; player.jumpBuffer=0; }

    function resetGame(){
      world.t=0; world.speed=world.baseSpeed; world.score=0;
      world.spawnCooldown = 40;      // short delay before first obstacle
      world.nextSpawnMin = 110;      // reset wide gaps
      world.nextSpawnMax = 170;
      world.difficultyTimer = 0;
      player.y=floorY; player.vy=0; player.onGround=true;
      player.jumps=0; player.usedDouble=false; player.coyote=0; player.jumpBuffer=0;
      obstacles.length=0; hardResetInput();
    }
    function startGame(){
      resetGame();
      world.alive = true;
      startScreen.style.display='none';
      gameOverEl.style.display='none';
    }
    function gameOver(){
      world.alive = false;
      finalScore.textContent = Math.floor(world.score);
      if(world.score > world.best){
        world.best = Math.floor(world.score);
        localStorage.setItem('vespa_best', world.best);
      }
      finalBest.textContent = world.best;
      gameOverEl.style.display = 'flex';
      hardResetInput();
    }

    // ===== Input handlers =====
    function keyHandler(e, down){
      if(e.keyCode===KEY.SPACE || e.keyCode===KEY.UP){
        if(down) e.preventDefault();
        if(e.keyCode===KEY.SPACE) keys.space = down; else keys.up = down;
        if(down && !world.alive){ startGame(); return; }     // start from menus
        if(down && world.alive){ player.jumpBuffer = BUFFER_FRAMES; } // buffer jump
      } else if(e.keyCode===KEY.R && down){
        startGame(); // allow R anytime
      }
    }
    window.addEventListener('keydown', e=>keyHandler(e,true));
    window.addEventListener('keyup',   e=>keyHandler(e,false));
    startBtn.addEventListener('click',   e=>{ e.preventDefault(); startGame(); });
    restartBtn.addEventListener('click', e=>{ e.preventDefault(); startGame(); });

    // ===== Gameplay =====
    function handlePlayerControls(){
      // coyote & buffer decay
      if(player.onGround) player.coyote = COYOTE_FRAMES; else if(player.coyote>0) player.coyote--;
      if(player.jumpBuffer>0) player.jumpBuffer--;

      // first jump
      if(player.jumpBuffer>0 && (player.onGround || player.coyote>0)){
        player.vy = JUMP_VEL_1; player.onGround=false; player.jumps=1; player.usedDouble=false; player.jumpBuffer=0;
      }
      // double jump
      else if(player.jumpBuffer>0 && !player.onGround && !player.usedDouble){
        player.vy = JUMP_VEL_2; player.usedDouble=true; player.jumps=2; player.jumpBuffer=0;
      }
    }

    function update(){
      world.t++;

      if(world.alive){
        // difficulty ramp: speed up a bit and narrow gaps slightly over time
        if(world.t % 240 === 0){ // ~every 4s
          world.speed = Math.min(world.speed + 0.5, world.maxSpeed);
          // gently reduce gap range but keep it reasonable
          world.nextSpawnMin = Math.max(85, world.nextSpawnMin - 4);
          world.nextSpawnMax = Math.max(120, world.nextSpawnMax - 6);
        }

        handlePlayerControls();

        // physics
        player.vy += gravity;
        player.y  += player.vy;
        if(player.y >= floorY){
          player.y = floorY; player.vy = 0;
          if(!player.onGround){ player.onGround=true; player.usedDouble=false; player.jumps=0; }
        } else {
          player.onGround = false;
        }

        // spawn & move obstacles (SAME SPEED AS ROAD)
        if(world.spawnCooldown > 0) world.spawnCooldown--;
        if(world.spawnCooldown <= 0) spawnTriangle();

        for(let i=obstacles.length-1;i>=0;i--){
          const o = obstacles[i];
          o.x -= world.speed; // ‚Üê same speed as road
          if(o.x + o.base < -100) obstacles.splice(i,1);
        }

        // scoring
        world.score += 0.2 + world.speed*0.012;

        // collisions (triangle bounding box, generous)
        const pb = getPlayerBounds();
        for(const o of obstacles){
          const ob = { x:o.x, y:o.y - o.height, w:o.base, h:o.height };
          if(rectsOverlap(pb, ob)){ gameOver(); break; }
        }
      }

      draw();
      requestAnimationFrame(update);
    }

    // ===== Bounds / Utils =====
    function getPlayerBounds(){
      // Tight-ish box under the PNG; bottom-centered
      return { x: player.x - player.w*0.45, y: player.y - player.h, w: player.w*0.9, h: player.h*0.95 };
    }
    function rectsOverlap(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    // ===== Drawing =====
    function drawRoad(){
      ctx.fillStyle = '#2a2a2a';
      ctx.fillRect(0, floorY, W, H-floorY);
      // lane hints scroll at half-rate‚Äîpurely cosmetic
      ctx.fillStyle = 'rgba(255,255,255,.25)';
      const stripeW = 120, stripeH = 6;
      const phase = (world.t*world.speed*0.5) % (stripeW*2);
      for(let x=-phase; x<W; x+=stripeW*2){
        ctx.fillRect(x,   floorY+30, stripeW, stripeH);
        ctx.fillRect(x+60,floorY+60, stripeW, stripeH);
      }
    }

    function drawTriangles(){
      for(const o of obstacles){
        // filled isosceles triangle resting on floor
        ctx.fillStyle = o.color;
        ctx.beginPath();
        ctx.moveTo(o.x,               o.y);
        ctx.lineTo(o.x + o.base/2,    o.y - o.height);
        ctx.lineTo(o.x + o.base,      o.y);
        ctx.closePath();
        ctx.fill();
      }
    }

    function drawVespa(){
      if(vespaReady){
        ctx.drawImage(vespaImg, player.x - player.w/2, player.y - player.h, player.w, player.h);
      }else{
        ctx.fillStyle = '#1e8bff';
        ctx.fillRect(player.x - player.w/2, player.y - player.h, player.w, player.h);
      }
      // shadow
      ctx.fillStyle = 'rgba(0,0,0,.16)';
      ctx.beginPath(); ctx.ellipse(player.x, player.y-2, player.w*0.44, 8, 0, 0, Math.PI*2); ctx.fill();
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      drawRoad();
      drawTriangles();
      drawVespa();
    }

    // go
    update();
  </script>
</body>
</html>
